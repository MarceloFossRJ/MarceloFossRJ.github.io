---
layout: post
title: Ruby calling Go code
date:   2019-07-15 18:44:25 -0300
category: [recipe]
tags: [ruby, RoR, go, golang, c, ffi]
author: Marcelo Foss
intro: |
  Go 1.5 added support for building shared libraries that are callable from C (and thus from Ruby via FFI). This makes the process easier than in pre-1.5 releases (when it was necessary to write the C glue layer), and the Go runtime is now usable, making this actually useful in real life (goroutines and memory allocations were not possible before, as they require the Go runtime, which was not useable if Go was not the main entry point).
---
Go introduced an important feature within version 1.5: the capability to compile Go packages into several formats including C archives, C shared libraries, Go archives, Go shared libraries and (introduced in 1.8) Go dynamic plugins.
This extended compile possibility is known as the Go Execution Modes, and can it is activated using the -buildmode flag.

I am going to focus in compiling the Go packages into C shared libraries, where the compiler outputs a standard shared object binary file (.so) exposing Go functions as a C-style APIs, which then can be called from Python, Ruby, C, Java, etc.

## The Go Code
There are four mandatory steps to be followed:
1- The package must be amain package. The compiler will build the package and all of its dependencies into a single shared object binary.
2- The source must import the pseudo-package “C”.
3- Use the //export comment to annotate functions you wish to make accessible to other languages.
4- An empty main function must be declared.

See the example below:

```go
package main
import "C"
import (
 "fmt"
 "math"
 "sort"
 "sync"
)
var count int
var mtx sync.Mutex
//export Add
func Add(a, b int) int { return a + b }
func Sort(vals []int) { sort.Ints(vals) }
//export Log
func Log(msg string) int {
  mtx.Lock()
  defer mtx.Unlock()
  fmt.Println(msg)
  count++
  return count
}
func main() {}
```

The package is compiled using the ```-buildmode=c-shared``` build flag to create the shared object binary:

```
$ go build -o awesome.so -buildmode=c-shared awesome.go
```

Upon completion, the compiler outputs two files:awesome.h, a C header file and awesome.so, the shared object file, shown below:

```
-rw-rw-r —    1362 Feb 11 07:59 awesome.h
-rw-rw-r — 1997880 Feb 11 07:59 awesome.so
```

Notice that the .so file is around 2 Mb, relatively large for such a small library. This is because the entire Go runtime machinery goodness and dependent packages are crammed into a single shared object binary (similar to compiling a single static executable).

The header file
The header file defines C types mapped to Go compatible types (using cgo semantics, not discussed here).

```
/* Created by “go tool cgo” — DO NOT EDIT. */
...
typedef long long GoInt64;
typedef GoInt64 GoInt;
...
typedef struct { const char *p; GoInt n; } GoString;
typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;
...
extern GoInt Add(GoInt p0, GoInt p1);
extern GoFloat64 Cosine(GoFloat64 p0);
...
```

The shared object file
The other file generated by the compiler is a 64-bit ELF shared object binary file. We can verify its information using the file command.

```
$> file awesome.so
awesome.so: ELF 64-bit LSB shared object, x86–64, version 1 (SYSV), dynamically linked, BuildID[sha1]=1fcf29a2779a335371f17219fffbdc47b2ed378a, not stripped
```

Using the nm and grep commands, we can inspect that our Go functions got exported.

```
$> nm awesome.so | grep -e "T Add" -e "T Cosine" -e "T Sort" -e "T Log"
00000000000d0db0 T Add
00000000000d0e30 T Cosine
00000000000d0f30 T Log
00000000000d0eb0 T Sort
```

Next, we will explore several examples showing how to invoke the exported functions from other languages.

From Python
In Python things get a little easier. The ctypes foreign function library is used to call the exported Go functions as shown in the following snippet (some print statements are omitted).

```
from ctypes import *
lib = cdll.LoadLibrary("./awesome.so")
lib.Add.argtypes = [c_longlong, c_longlong]
print "awesome.Add(12,99) = %d" % lib.Add(12,99)
lib.Cosine.argtypes = [c_double]
lib.Cosine.restype = c_double
cos = lib.Cosine(1)
print "awesome.Cosine(1) = %f" % cos
class GoSlice(Structure):
    _fields_ = [("data", POINTER(c_void_p)),
                ("len", c_longlong), ("cap", c_longlong)]
nums = GoSlice((c_void_p * 5)(74, 4, 122, 9, 12), 5, 5)
lib.Sort.argtypes = [GoSlice]
lib.Sort.restype = None
lib.Sort(nums)
class GoString(Structure):
    _fields_ = [("p", c_char_p), ("n", c_longlong)]
lib.Log.argtypes = [GoString]
msg = GoString(b"Hello Python!", 13)
lib.Log(msg)
# See client.py on GitHub
```
The lib variable represents the loaded symbols from the shared object file. Python classes GoString and GoSlice map to their respective C struct types. When the Python code is executed, it calls the Go functions in the shared object producing the following output:
```
$> python client.py
awesome.Add(12,99) = 111
awesome.Cosine(1) = 0.540302
awesome.Sort(74,4,122,9,12) = [ 4 9 12 74 122 ]
Hello Python!
```

From Ruby
Calling Go functions from Ruby follows a similar pattern as above using the FFI gem to dynamically load and call exported Go functions as shown in the following snippet.
```
require 'ffi'
module Awesome
  extend FFI::Library
  ffi_lib './awesome.so'
  class GoSlice < FFI::Struct
    layout :data,  :pointer,
           :len,   :long_long,
           :cap,   :long_long
  end
  class GoString < FFI::Struct
    layout :p,     :pointer,
           :len,   :long_long
  end
  attach_function :Add, [:long_long, :long_long], :long_long
  attach_function :Cosine, [:double], :double
  attach_function :Sort, [GoSlice.by_value], :void
  attach_function :Log, [GoString.by_value], :int
end

print "awesome.Add(12, 99) = ",  Awesome.Add(12, 99), "\n"
print "awesome.Cosine(1) = ", Awesome.Cosine(1), "\n"
nums = [92,101,3,44,7]
ptr = FFI::MemoryPointer.new :long_long, nums.size
ptr.write_array_of_long_long  nums
slice = Awesome::GoSlice.new
slice[:data] = ptr
slice[:len] = nums.size
slice[:cap] = nums.size
Awesome.Sort(slice)
msg = "Hello Ruby!"
gostr = Awesome::GoString.new
gostr[:p] = FFI::MemoryPointer.from_string(msg)
gostr[:len] = msg.size
Awesome.Log(gostr)
# See client.rb on GitHub
```
In Ruby, the FFI::library class is extended to declare a class that loads the exported symbols. Classes GoSlice and GoString map to their respective C structs. When we run the code it calls the exported Go functions as shown below:
```
$> ruby client.rb
awesome.Add(12, 99) = 111
awesome.Cosine(1) = 0.5403023058681398
awesome.Sort([92, 101, 3, 44, 7]) = [3, 7, 44, 92, 101]
Hello Ruby!
```

https://medium.com/learning-the-go-programming-language/calling-go-functions-from-other-languages-4c7d8bcc69bf

https://stackoverflow.com/questions/15879993/writing-a-ruby-extension-in-go-golang
